<html>

<head>
  <script src="https://www.gstatic.com/firebasejs/4.8.2/firebase.js"></script>
  <script src="https://www.gstatic.com/firebasejs/4.9.0/firebase-firestore.js"></script>

</head>

<body>
  <div id="player"></div>
  <script>
    var config = {
      apiKey: "AIzaSyCCguN3p2gYlFbLTEgK7WtlrJlazJ6TgLs",
      authDomain: "cowatch-fb.firebaseapp.com",
      projectId: "cowatch-fb"
    };
    var sendChannel;

    function receiveChannelCallback(event) {
      sendChannel = event.channel;
      sendChannel.onmessage = handleReceiveMessage;
    }

    var peerConnectionConfig = {
      'iceServers': [
        { 'urls': ['stun:stun.l.google.com:19302'] }]
    };

    firebase.initializeApp(config);
    var db = firebase.firestore();
    var room = window.location.hash.substring(1);
    var receivedOffer;
    var pongListeners = []

    function send(msg) {
      if (sendChannel && sendChannel.readyState == 'open') {
        sendChannel.send(JSON.stringify(msg))
      }
    }
    peerConnections = [];

    myOfferConnection = new RTCPeerConnection(peerConnectionConfig);
    myOfferConnection.ondatachannel = receiveChannelCallback;
    receiveChannelCallback({ channel: myOfferConnection.createDataChannel("sendChannel") });

    var offerPromise = myOfferConnection.createOffer();
    myOfferConnection.onicecandidate = function (event) {
      console.log("on my ice", event.candidate)
      offerPromise.then(offer => {
        event.candidate && db.collection("iceCandidates").add({
          sdp: offer.sdp,
          ice: JSON.parse(JSON.stringify(event.candidate))
        })
      })
    };

    offerPromise.then(offer => {

      myOfferConnection.setLocalDescription(offer);
      console.log("Submitting my offer", offer);

      db.collection("offers").add({
        offer: offer.sdp,
        room: room,
      })

      db.collection("offers").where("room", "==", room).onSnapshot(snapshot => {
        console.log("new snapshopt", snapshot.docChanges.map(c => c.doc.data()));

        var answers = snapshot.docChanges
          .filter(c => c.type === "modified")
          .filter(c => c.doc.data().offer === offer.sdp);

        console.log("rows about this offer", offer.sdp, answers.length, answers.map(c => [c.type, c.doc.data()]))

        answers = answers
          .filter(c => c.doc.data().answer);

        if (answers.length === 1) {
          var answer = { type: 'answer', sdp: answers[0].doc.data().answer }
          console.log("Got answer to my initial offer!", answer)
          myOfferConnection.setRemoteDescription(answer).then(function () {
            console.log("Sey my remote since my offer was answered")
            db.collection("iceCandidates").where("sdp", "==", answer.sdp).onSnapshot(iceSnapshot => {
              iceSnapshot.docChanges
                .filter(c => c.type === 'added')
                .forEach(c => {
                  console.log("Saw ice candidae for remote on myOFfer")
                  myOfferConnection.addIceCandidate(new RTCIceCandidate(c.doc.data().ice));
                })
            })
          });
          return;
        }

        var newOffers = snapshot.docChanges
          .filter(c => c.type === "added")
          .filter(c => c.doc.data().offer !== offer.sdp);

        if (newOffers.length > 1) return;
        if (newOffers.length == 0) return;
        console.log("Seeing a new offer initiated by peer!")
        peerConnection = new RTCPeerConnection(peerConnectionConfig);
        peerConnections.push(peerConnection);
        peerConnection.ondatachannel = receiveChannelCallback;
        var answer = { type: 'offer', sdp: newOffers[0].doc.data().offer };
        peerConnection.setRemoteDescription(answer).then(function () {
          db.collection("iceCandidates").where("sdp", "==", answer.sdp).onSnapshot(iceSnapshot => {
            iceSnapshot.docChanges
              .filter(c => c.type === 'added')
              .forEach(c => {
                console.log("Saw ice candidae for remote peer's offer")
                peerConnection.addIceCandidate(new RTCIceCandidate(c.doc.data().ice));
              })
          })

          console.log("Creating a peer to respond to a new offer")
        });

        var answerPromise = peerConnection.createAnswer()
        peerConnection.onicecandidate = function (event) {
          console.log("on peer ice", event.candidate)
          answerPromise.then(offer => {
            event.candidate && db.collection("iceCandidates").add({
              sdp: offer.sdp,
              ice: JSON.parse(JSON.stringify(event.candidate))
            })
          })
        };

        answerPromise.then(answer => {
          console.log("Created answer", answer);
          peerConnection.setLocalDescription(answer).then(() => {
            console.log("Set peer connection desc", answer);
          })
          newOffers[0].doc.ref.update({ answer: answer.sdp })
        }).catch(e => { console.log("Create ansewr failed ", e) });

      })
    })
      .catch(e => { console.log("Peer connection offer creat err", e) });

    var sendChannel;

    function checkTime(ping) {
      send(ping)
      return new Promise((resolve, reject) => {
        var resolveIfMatch = {
          notify: (pong) => {
            if (pong.pingClock == ping.clock) {
              resolve(pong)
              pongListeners = pongListeners.filter(x => x !== resolveIfMatch)
            }
          }
        }
        pongListeners.push(resolveIfMatch)
      })
    }

    setInterval(() => {
      var ping = {
        ping: true,
        clock: new Date().getTime(),
        videoTime: player && player.getCurrentTime && player.getCurrentTime()
      }
      checkTime(ping).then(pong => {
        console.log("Time delay", pong.clock - pong.pingClock, pong.videoTime, ping.videoTime, pong.videoTime - ping.videoTime)
        if (Math.abs(ping.videoTime - pong.videoTime) > 1 + Math.abs(pong.clock - ping.clock) / 1000) {
          console.log("Out of sync!");
          player.pauseVideo();
          player.seekTo(Math.min(ping.videoTime, pong.videoTime))
          send({event: 2, currentTime: Math.min(ping.videoTime, pong.videoTime)})
        }
      });
    }, 1000)

    var lastMessage = new Date().getTime();
    function handleReceiveMessage(msg) {
      console.log("Received raw", msg)
      data = JSON.parse(msg.data);
      lastMessage = new Date().getTime();
      console.log("Parsed", data)

      if (data.ping) {
        return send({
          pong: true,
          pingClock: data.clock,
          clock: new Date().getTime(),
          videoTime: player && player.getCurrentTime && player.getCurrentTime()
        })
      }

      if (data.pong) {
        return pongListeners.forEach(l => l.notify(data))
      }

      console.log("look events", data, data.ping, data.pong, data.event)
      if (data.event == 2) {
        console.log("So pause, they did")
        player.pauseVideo();
      }
      if (data.event == 2 || data.event == 3) {
        player.seekTo(data.currentTime);
      }
      if (data.event == 1) {
        player.playVideo();
      }
    }

    function createOfferError(error) {
      console.log(error);
    }
    var tag = document.createElement('script');

    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    var player;
    function onYouTubeIframeAPIReady() {
      player = new YT.Player('player', {
        height: '390',
        width: '640',
        playerVars: { start: 0 },
        videoId: room,
        events: {
          'onReady': onPlayerReady,
          'onStateChange': onPlayerStateChange
        }
      });
    }

    // 4. The API will call this function when the video player is ready.
    function onPlayerReady(event) {
      //event.target.playVideo();
    }

    function onPlayerStateChange(event) {
      console.log("YT Event", event, player.getCurrentTime())
      if ((new Date().getTime() - lastMessage) > 200) {
        send({
          event: event.data,
          currentTime: player.getCurrentTime()
        });
      }
    }

  </script>
</body>

</html>