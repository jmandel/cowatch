<html>

<head>
  <script src="https://www.gstatic.com/firebasejs/4.8.2/firebase.js"></script>
  <script src="https://www.gstatic.com/firebasejs/4.9.0/firebase-firestore.js"></script>

</head>

<body>
  <div id="player"></div>
  <script>
    var config = {
      apiKey: "AIzaSyCCguN3p2gYlFbLTEgK7WtlrJlazJ6TgLs",
      authDomain: "cowatch-fb.firebaseapp.com",
      projectId: "cowatch-fb"
    };

    var sendChannel;
    function receiveChannelCallback(event) {
      sendChannel = event.channel;
      sendChannel.onmessage = handleReceiveMessage;
    }

    var peerConnectionConfig = {
      'iceServers': [
        { 'urls': ['stun:stun.l.google.com:19302'] }]
    };

    firebase.initializeApp(config);
    var db = firebase.firestore();
    var room = window.location.hash.substring(1);
    var receivedOffer;
    var pongListeners = []

    function send(msg) {
      if (sendChannel && sendChannel.readyState == 'open') {
        sendChannel.send(JSON.stringify(msg))
      }
    }
    peerConnections = [];

    myOfferConnection = new RTCPeerConnection(peerConnectionConfig);
    myOfferConnection.ondatachannel = receiveChannelCallback;
    receiveChannelCallback({ channel: myOfferConnection.createDataChannel("sendChannel") });

    var offerPromise = myOfferConnection.createOffer();
    myOfferConnection.onicecandidate = function (event) {
      console.log("on my ice", event.candidate)
      offerPromise.then(offer => {
        event.candidate && db.collection("iceCandidates").add({
          sdp: offer.sdp,
          ice: JSON.parse(JSON.stringify(event.candidate))
        })
      })
    };

    offerPromise.then(offer => {

      myOfferConnection.setLocalDescription(offer);
      console.log("Submitting my offer", offer);

      db.collection("offers").add({
        offer: offer.sdp,
        room: room,
      })

      db.collection("offers").where("room", "==", room).onSnapshot(snapshot => {
        console.log("new snapshopt", snapshot.docChanges.map(c => c.doc.data()));

        var answers = snapshot.docChanges
          .filter(c => c.type === "modified")
          .filter(c => c.doc.data().offer === offer.sdp);

        console.log("rows about this offer", offer.sdp, answers.length, answers.map(c => [c.type, c.doc.data()]))

        answers = answers
          .filter(c => c.doc.data().answer);

        if (answers.length === 1) {
          var answer = { type: 'answer', sdp: answers[0].doc.data().answer }
          myOfferConnection.setRemoteDescription(answer).then(function () {
            db.collection("iceCandidates").where("sdp", "==", answer.sdp).onSnapshot(iceSnapshot => {
              iceSnapshot.docChanges
                .filter(c => c.type === 'added')
                .forEach(c => {
                  console.log("Saw ice candidae for remote on myOFfer")
                  myOfferConnection.addIceCandidate(new RTCIceCandidate(c.doc.data().ice));
                })
            })
          });
          return;
        }

        var newOffers = snapshot.docChanges
          .filter(c => c.type === "added")
          .filter(c => c.doc.data().offer !== offer.sdp);

        if (newOffers.length > 1) return;
        if (newOffers.length == 0) return;
        peerConnection = new RTCPeerConnection(peerConnectionConfig);
        peerConnections.push(peerConnection);
        peerConnection.ondatachannel = receiveChannelCallback;
        var answer = { type: 'offer', sdp: newOffers[0].doc.data().offer };
        peerConnection.setRemoteDescription(answer).then(function () {
          db.collection("iceCandidates").where("sdp", "==", answer.sdp).onSnapshot(iceSnapshot => {
            iceSnapshot.docChanges
              .filter(c => c.type === 'added')
              .forEach(c => {
                console.log("Saw ice candidae for remote peer's offer")
                peerConnection.addIceCandidate(new RTCIceCandidate(c.doc.data().ice));
              })
          })
        });

        var answerPromise = peerConnection.createAnswer()
        peerConnection.onicecandidate = function (event) {
          answerPromise.then(offer => {
            event.candidate && db.collection("iceCandidates").add({
              sdp: offer.sdp,
              ice: JSON.parse(JSON.stringify(event.candidate))
            })
          })
        };

        answerPromise.then(answer => {
          peerConnection.setLocalDescription(answer).then(() => { })
          newOffers[0].doc.ref.update({ answer: answer.sdp })
        }).catch(e => { console.log("Create ansewr failed ", e) });

      })
    }).catch(e => { console.log("Peer connection offer creat err", e) });

    var sendChannel;

    function checkTime(ping) {
      send(ping)
      return new Promise((resolve, reject) => {
        var resolveIfMatch = {
          notify: (pong) => {
            if (pong.pingClock == ping.clock) {
              resolve(pong)
              pongListeners = pongListeners.filter(x => x !== resolveIfMatch)
            }
          }
        }
        pongListeners.push(resolveIfMatch)
      })
    }

    setInterval(() => {
      var ping = {
        ping: true,
        clock: new Date().getTime(),
        videoTime: player && player.getCurrentTime && player.getCurrentTime()
      }
      checkTime(ping).then(pong => {
        //console.log("Time delay", pong.clock - pong.pingClock, pong.videoTime, ping.videoTime, pong.videoTime - ping.videoTime)
        var pongTime = new Date().getTime()
        var RTT = Math.abs(pongTime - ping.clock) 
        if (Math.abs(ping.videoTime - pong.videoTime) > 1 + .5 * RTT / 1000) {
          console.log("Out of sync!");
          if (lastMessage > ping.clock - 5000) return;
          if (pong.videoTime > ping.videoTime) return;
          if (player.getPlayerState() != YT.PlayerState.PLAYING) return;
          console.log("And fixing")
          targetState.videoTime = pong.videoTime + .5 * RTT / 1000
          enforceState(targetState)
        } else {
          targetState.videoTime = Math.min(pong.videoTime, ping.videoTime)
        }
      });
    }, 1000)

    var lastMessage = new Date().getTime();

    targetState = {
      step: 0,
      playing: false,
      videoTime: 0
    }

    function enforceState(state) {
      if (!player || !player.seekTo || !player.playVideo) return;
      player.seekTo(state.videoTime)
      if (state.playing) player.playVideo()
      else player.pauseVideo()
      lastMessage = new Date().getTime();
    }

    function handleReceiveMessage(msg) {
      //console.log("Received raw", msg)
      data = JSON.parse(msg.data);
      //console.log("Parsed", data)

      if (data.state) {// && data.state.step > targetState.step){
        targetState = data.state;
        console.log("New state from msg")
        enforceState(targetState)
      }
      else if (data.state) {
        console.log("out of order", data.state)
      }

      if (data.ping) {
        return send({
          pong: true,
          pingClock: data.clock,
          clock: new Date().getTime(),
          videoTime: player && player.getCurrentTime && player.getCurrentTime()
        })
      }

      if (data.pong) {
        return pongListeners.forEach(l => l.notify(data))
      }

    }

    function createOfferError(error) {
      console.log(error);
    }
    var tag = document.createElement('script');

    tag.src = "https://www.youtube.com/iframe_api";
    var firstScriptTag = document.getElementsByTagName('script')[0];
    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

    var player;
    function onYouTubeIframeAPIReady() {
      player = new YT.Player('player', {
        height: '390',
        width: '640',
        playerVars: { start: 0 },
        videoId: room,
        events: {
          'onReady': onPlayerReady,
          'onStateChange': onPlayerStateChange
        }
      });
    }

    // 4. The API will call this function when the video player is ready.
    function onPlayerReady(event) {
      //event.target.playVideo();
    }

    function onPlayerStateChange(event) {
      console.log("YT Event", event, player.getCurrentTime())
      if (event.data != YT.PlayerState.PLAYING && event.data != YT.PlayerState.PAUSED) return
      console.log("Tine diff", player.getCurrentTime(), targetState.videoTime)
      var state = {
        step: targetState.step + 1,
        playing: event.data == YT.PlayerState.PLAYING,
        videoTime: player.getCurrentTime()
      }

      if (targetState.playing === state.playing && Math.abs(targetState.videoTime - state.videoTime) < 0.1){
        return
      }

      targetState = state;
      if (new Date().getTime() - lastMessage < 1000) return
      console.log("UPdate taget", targetState)
      send({
        state: state
      })
    }

  </script>
</body>

</html>